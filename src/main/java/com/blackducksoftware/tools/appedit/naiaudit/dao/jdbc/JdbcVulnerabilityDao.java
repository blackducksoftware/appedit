package com.blackducksoftware.tools.appedit.naiaudit.dao.jdbc;

import java.util.ArrayList;
import java.util.Date;
import java.util.List;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.TimeUnit;

import javax.inject.Inject;

import org.apache.commons.lang3.StringUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.jdbc.BadSqlGrammarException;
import org.springframework.jdbc.core.namedparam.MapSqlParameterSource;
import org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate;
import org.springframework.jdbc.core.namedparam.SqlParameterSource;

import com.blackducksoftware.tools.appedit.core.exception.AppEditException;
import com.blackducksoftware.tools.appedit.naiaudit.dao.VulnerabilityDao;
import com.blackducksoftware.tools.connector.codecenter.common.RequestVulnerabilityPojo;
import com.blackducksoftware.tools.connector.codecenter.common.VulnerabilitySeverity;
import com.google.common.cache.CacheBuilder;
import com.google.common.cache.CacheLoader;
import com.google.common.cache.LoadingCache;

public class JdbcVulnerabilityDao implements VulnerabilityDao {
	private static final String REM_STATUS_VALUE_IF_NULL = "Unreviewed";
	private final Logger logger = LoggerFactory.getLogger(this.getClass().getName());
	private static final String SQL_FETCH_ONE_VULNERABILITY_BY_ID = "SELECT nvd_cve_id, name, status, dsc, comments, cvss_base_score, cvss_exploit_subscore, cvss_impact_subscore, severity, published, modified, created, updated FROM vulnerabilities WHERE nvd_cve_id = :vulnId";
	private static final String SQL_FETCH_REQUEST_VULNERABILITIES_BY_REQUEST_ID = "SELECT id, vulnerability_status_id, componentuse_id, vulnerability_id, comment, date_remediation, date_completion FROM componentuse_vulnerability WHERE componentuse_id = :requestId";
	private static final String SQL_FETCH_REM_STATUS_NAME = "SELECT id, name FROM vulnerability_status WHERE id = :remStatusId";

	private LoadingCache<Long, String> remStatusById;

	private NamedParameterJdbcTemplate jdbcTemplateBdsVuln;

	@Inject
	public void setJdbcTemplateBdsVuln(final NamedParameterJdbcTemplate jdbcTemplateBdsVuln) {
		this.jdbcTemplateBdsVuln = jdbcTemplateBdsVuln;
	}

	private NamedParameterJdbcTemplate jdbcTemplateBdsCatalog;

	@Inject
	public void setJdbcTemplateBdsCatalog(final NamedParameterJdbcTemplate jdbcTemplateBdsCatalog) {
		this.jdbcTemplateBdsCatalog = jdbcTemplateBdsCatalog;
	}

	public JdbcVulnerabilityDao() {
		remStatusById = CacheBuilder.newBuilder().maximumSize(100).expireAfterWrite(1, TimeUnit.HOURS)
				.build(new CacheLoader<Long, String>() {
					@Override
					public String load(final Long remStatusId) throws AppEditException {
						return loadRemediationStatusName(remStatusId);
					}
				});
	}

	@Override
	public List<RequestVulnerabilityPojo> getVulnerabilitiesByRequestId(final String requestId) throws AppEditException {
		final List<RequestVulnerabilityPojo> compositeVulns = new ArrayList<>();

		final SqlParameterSource requestVulnNamedParameters = new MapSqlParameterSource("requestId", requestId);
		String queryString = SQL_FETCH_REQUEST_VULNERABILITIES_BY_REQUEST_ID;
		List<RequestVulnerability> requestVulns;
		try {
			logger.debug("JDBC: Executing query: " + queryString);
			requestVulns = jdbcTemplateBdsCatalog.query(queryString,
					requestVulnNamedParameters,
					new RequestVulnerabilityMapper());
			logger.debug("JDBC: Done executing query; item count: " + requestVulns.size());
		} catch (final BadSqlGrammarException e) {
			logger.debug("JDBC: Error executing query");
			final String msg = "Error getting Request Vulnerabilities with Request ID " + requestId + ": "
					+ e.getMessage();
			logger.error(msg);
			throw new AppEditException(msg);
		}
		logger.debug("Read " + requestVulns.size() + " RequestVulnerability records for request ID " + requestId);
		for (final RequestVulnerability requestVuln : requestVulns) {
			logger.debug("RequestVulnerability: " + requestVuln);

			final int vulnId = requestVuln.getVulnerabilityId();

			final SqlParameterSource vulnNamedParameters = new MapSqlParameterSource("vulnId",
					vulnId);
			queryString = SQL_FETCH_ONE_VULNERABILITY_BY_ID;
			final List<Vulnerability> vulns;
			try {
				logger.debug("JDBC: Executing query: " + queryString);
				vulns = jdbcTemplateBdsVuln.query(queryString, vulnNamedParameters,
						new VulnerabilityMapper());
				logger.debug("JDBC: Done executing query; item count: " + vulns.size());
			} catch (final BadSqlGrammarException e) {
				logger.error("JDBC: Error executing query");
				final String msg = "Error getting Vulnerability with ID " + vulnId + ": " + e.getMessage();
				logger.error(msg);
				throw new AppEditException(msg);
			}

			if (vulns.size() == 0) {
				throw new AppEditException("Vulnerability with ID " + vulnId
						+ " referenced in componentuse_vulnerability table, but not found in vulnerabilities table");
			}

			if (vulns.size() > 1) {
				throw new AppEditException(
						"More than one vulnerability found in vulnerabilities table for Vulnerability ID " + vulnId);
			}

			final Vulnerability vuln = vulns.get(0);
			logger.debug("Vulnerability: " + vuln);

			final String vulnerabilityId = String.valueOf(vuln.getNvdCveId());
			final String vulnerabilityName = vuln.getName();
			final String description = vuln.getDescription();
			final String sevString = vuln.getSeverity();
			final VulnerabilitySeverity severity = getSeverity(sevString);
			final String baseScore = vuln.getBaseScore();
			final String exploitabilityScore = vuln.getExploitabilityScore();
			final String impactScore = vuln.getImpactScore();
			final Date dateCreated = vuln.getDateCreated();
			final Date dateModified = vuln.getDateModified();
			final Date datePublished = vuln.getDatePublished();
			String reviewStatusName = getRemediationStatusName(requestVuln.getVulnerabilityStatusId());
			reviewStatusName = adjustReviewStatusName(reviewStatusName);
			final String comments = requestVuln.getComment();
			final Date targetRemediationDate = requestVuln.getDateRemediation();
			final Date actualRemediationDate = requestVuln.getDateCompletion();

			final RequestVulnerabilityPojo compositeVuln = new RequestVulnerabilityPojo(vulnerabilityId,
					vulnerabilityName,
					description, severity, baseScore, exploitabilityScore, impactScore, dateCreated, dateModified,
					datePublished, requestId, comments, reviewStatusName, targetRemediationDate, actualRemediationDate);


			compositeVulns.add(compositeVuln);

		}

		return compositeVulns;
	}

	private String adjustReviewStatusName(final String origName) {
		if (StringUtils.isBlank(origName)) {
			logger.debug("Converting null remediation status to: " + REM_STATUS_VALUE_IF_NULL);
			return REM_STATUS_VALUE_IF_NULL;
		}
		return origName;
	}

	private String getRemediationStatusName(final long remStatusId) throws AppEditException {
		if (remStatusId == 0) {
			return "";
		}

		try {
			return remStatusById.get(remStatusId);
		} catch (final ExecutionException e) {
			final String msg = "Error getting remediation status name for id: " + remStatusId + ": " + e.getMessage();
			logger.error(msg);
			throw new AppEditException(msg);
		}
	}

	private String loadRemediationStatusName(final long remStatusId) throws AppEditException {
		logger.debug("Loading remediation status name for ID: " + remStatusId);
		final String queryString = SQL_FETCH_REM_STATUS_NAME;
		final SqlParameterSource namedParameters = new MapSqlParameterSource("remStatusId", remStatusId);

		List<RemediationStatusName> remStatusNames;
		try {
			logger.debug("JDBC: Executing query: " + queryString);
			remStatusNames = jdbcTemplateBdsCatalog
					.query(queryString, namedParameters,
							new RemediationStatusNameMapper());
			logger.debug("JDBC: Done executing query; item count: " + remStatusNames.size());
		} catch (final BadSqlGrammarException e) {
			logger.debug("JDBC: Error executing query");
			final String msg = "Error getting remediation status names" + e.getMessage();
			logger.error(msg);
			throw new AppEditException(msg);
		}
		logger.debug("Read " + remStatusNames.size() + " remediation status names");

		if (remStatusNames.size() == 0) {
			final String msg = "Remediation status name for ID " + remStatusId + " not found";
			logger.error(msg);
			throw new AppEditException(msg);
		} else if (remStatusNames.size() > 1) {
			final String msg = "Found more than one remediation status name for ID " + remStatusId;
			logger.error(msg);
			throw new AppEditException(msg);
		}
		return remStatusNames.get(0).getName();
	}

	private VulnerabilitySeverity getSeverity(final String sevString) {
		if ("Medium".equalsIgnoreCase(sevString)) {
			return VulnerabilitySeverity.MEDIUM;
		} else if ("High".equalsIgnoreCase(sevString)) {
			return VulnerabilitySeverity.MEDIUM;
		} else {
			return VulnerabilitySeverity.LOW;
		}
	}
}
